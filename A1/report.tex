\documentclass[11pt]{article}

\usepackage{sectsty}
\usepackage{graphicx}
\usepackage{algpseudocode}
\usepackage{algorithm}

% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\title{ Operating Systems - Assignment 1}
\author{ Aryan Nath }
\date{\today}

\begin{document}
\maketitle	

% Optional TOC
% \tableofcontents
% \pagebreak

%--Paper--
% A PDF containing explanations for how youâ€™ve deployed multi-threading as well as pseudocode for your multi-threaded approach.
\section{Explanation for Multithreading:}
I have a function for running the Floyd Warshall algorithm on a graph input represented by the dist matrix. In the non-threaded approach there are three loops, the loop with the $k$ iterator, the loop with the $i$ iterator, and the loop with the $j$ iterator. For implementing this using multithreading, for each iteration of the $i$ loop, I have created a new thread and passed the value of the row ($i$), $k$, and a pointer to the dist matrix as a struct to the function thread\_rowcompute() which computes updates all of the column in the row $i$ of the dist matrix. Then after the $i$ loop has terminated, I joined the threads and repeated this in the next iteration of the $k$ loop.\\

\noindent \textbf{Pseudocode for Multithreading:}

\noindent (Next page)\\

\noindent Running the code:
\begin{enumerate}
\item Add input to input.txt
\item Run make
\item Run ./main
\item Check output.txt
\end{enumerate}

\begin{algorithm}
\caption{Multithreaded Floyd-Warshall Algorithm}
\begin{algorithmic}[1]

\State \textbf{Define} $INF = 100000$

\State \textbf{Structure} $distrow$:
\State \hspace{\algorithmicindent} $row$: integer
\State \hspace{\algorithmicindent} $distmatrix$: pointer to integer array
\State \hspace{\algorithmicindent} $squaremat\_width$: integer
\State \hspace{\algorithmicindent} $intermediate\_node$: integer

\Function{ThreadRowCompute}{distmat\_struct}
    \State $distmat \gets distmat\_struct.distmatrix$
    \State $row \gets distmat\_struct.row$
    \State $k \gets distmat\_struct.intermediate\_node$
    \State $N \gets distmat\_struct.squaremat\_width$
    
    \For{$j \gets 0$ to $N-1$}
        \If{$distmat[row][k] + distmat[k][j] < distmat[row][j]$}
            \State $distmat[row][j] \gets distmat[row][k] + distmat[k][j]$
        \EndIf
    \EndFor
    
    \State Free $distmat\_struct$
    \State \Return NULL
\EndFunction

\Function{FloydWarshall}{$N$, $dist[N][N]$}
    \For{$k \gets 0$ to $N-1$}
        \State $tid \gets$ Allocate array of $N$ thread IDs
        \State $start\_time \gets$ Current time
        
        \For{$i \gets 0$ to $N-1$}
            \State $distmat\_struct \gets$ Allocate new structure of type $distrow$
            \State $distmat\_struct.distmatrix \gets dist$
            \State $distmat\_struct.row \gets i$
            \State $distmat\_struct.intermediate\_node \gets k$
            \State $distmat\_struct.squaremat\_width \gets N$
            \State Create thread $tid[i]$ running \Call{ThreadRowCompute}{$distmat\_struct$}
        \EndFor
        
        \State $end\_time \gets$ Current time
        \State $execution\_time \gets (end\_time - start\_time) / CLOCKS\_PER\_SEC$
        \State Output "Execution time for loop $k=k$: $execution\_time$ seconds"
        
        \For{$i \gets 0$ to $N-1$}
            \State Wait for thread $tid[i]$ to complete
        \EndFor
        
        \State Free $tid$
    \EndFor
\EndFunction

\end{algorithmic}
\end{algorithm}


\section{Runtime Comparison}

Execution time for loop k=0: 0.000126 seconds\\
Execution time for loop k=1: 0.000095 seconds\\
Execution time for loop k=2: 0.000067 seconds\\
Execution time for loop k=3: 0.000089 seconds\\
Execution time(without threading): 0.000002 seconds\\

\noindent Despite using threading, we could not achieve a lower runtime than the standard sequential approach. This is probably because of the extra overhead caused by the struct creation, which is passed as an argument in to the function run by each thread, thread creation, and thread joining.

\pagebreak 
\section{Achieved Output}
0 1 2 1 \\
1 0 1 2 \\
2 1 0 1 \\
1 2 1 0 \\

\noindent (written to output.txt)

\section{Theoretical Time Complexity}
Since the threads in the 2nd loop are running in parallel, the theoretical time complexity of the the program should be $O(n^2)$ instead of $O(n^3)$. However, this definitely does not execute as two nested for loops due to various possible delays from process scheduling and the overhead from thread creation and joining.

\end{document}